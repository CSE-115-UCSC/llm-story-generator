# LLM Story Generator

Eaach story that you generate will have its own model.

# Story \<object>

Every story yoou create will have it's own instance. We'll keep track of it on our end. 

```
# Create a global story object.
story = Story("Raj's Grand Adventure")

# get chapter 1 from the story.
story.chapter(1)

# add a chapter to our model generated by an LLM.
story.set_chapter(

"Raj stood his ground as the tiger lunged, its eyes   blazing with ferocity. Armed only with a sturdy stick and his quick reflexes, he sidestepped the beastâ€™s powerful swipe. The jungle echoed with the sounds of their fierce battle. With a well-timed strike, Raj managed to hit the tiger on its snout, momentarily stunning it. Seizing the opportunity, he jabbed the stick into the ground, creating a barrier. The tiger, disoriented, retreated into the shadows. Breathing heavily, Raj knew he had won, not just against the tiger, but against his own fears. The jungle fell silent once more.", 1

)

# get the character object by name.
story.character("Raj")

# add a character with the followinf characteristics.
story.set_character("Raj", ["courageous", "resourceful", "quick reflexes", "strategic", "resilient"])

```
### Attributes
#### chapters: array[Chapter Object]
Chapter objects are stored in an array. The reason for this is because arrays take up less space in memory then dictionaries (and, when the situation is right, like this one, also has constant lookup time.) There's another reason, though. The array access feels more intuitive:

```
Story().chapters[1] # more intuitive

Story().chapters["1"] # less intuitive
```

On our end. ```Story().chapters[0]``` is the initial element of the array and contains ```None``` so that ```chapters.append(<ref to Chapter Object>)``` starts at index 1, so the first chapter corresponds to the 1st element as opposed to the 0th one.

#### characters: dict[str: Character Object]
Character Objects are stored in a dicctionary for fast look ups. The mapping is character name to a reference to the character object.

### Methods
#### chapter(chapter_number: int)
Every chapter has its own chapter object. Here we assume that the chapter number already exists. This will check the story for the chapter number, and return a [Chapter Object]().

#### set_chapter(text: str, chapter_number: int or None)
This function creates a [Chapter Object]() representing a new chapter and adds that chapter to the story. 

#### character(name: str)
Every character has its own [Character Object](). This finds the Character object by character name, then returns that character object.

#### set_character(name: str, attributes: str)
Characters new to the story will have a [Character Object]() created for them.

# Chapter \<object>
Every chapter you write is represented in our backend as its own object. Your objects will almost always be accessed using ```Story``` objects:
```
story.chapter(1)
```
## Attributes
```
Chapter.text = the content of the chapter stored as a string
Chapter.number = like chapter 1, chapter 2, chapter 3, etc. Stored as an int 
```

# Character \<object>

## Attributes
```
Chararcter.name = a string
Character.traits = a list of strings
```